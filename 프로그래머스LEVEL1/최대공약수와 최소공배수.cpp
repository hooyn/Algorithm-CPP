//문제 설명
//두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, 
//solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 
//그다음 최소공배수를 넣어 반환하면 됩니다. 
//예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 
//solution(3, 12)는 [3, 12]를 반환해야 합니다.

//제한 사항
//두 수는 1이상 1000000이하의 자연수입니다.

/*<지식-유클리드호제법>
[최대공약수]
a > b 일 때,
a / b = 몫 ... 나머지1
b / 나머지1 = 몫 ... 나머지2
나머지1 / 나머지2 = 몫 ... 나머지3
나머지2 / 나머지3 = 몫 ... 나머지4
...
나머지(n-1) / 나머지n = 몫 ... 0
나머지가 0일 때 나누는 수(나머지n)이 최대공약수이다.

[최소공배수]
-> a * b = 최대공약수 * X * 최대공약수 * Y
-> a * b / 최대공약수 = 최대공약수 * X * Y
-> a * b / 최대공약수 = 최소공배수 이다.*/

#include <string>
#include <vector>
using namespace std;

vector<int> solution(int n, int m) {
    vector<int> answer;
    int min, max, rem;
    
    if (n < m) {
        min = n; max = m;
    }
    else {
        min = m; max = n;
    }
    
    while(true) {
        rem = max % min;
        if(rem == 0){
            answer.push_back(min);
            break;
        }
        max = min;
        min = rem;
    }

    answer.push_back((n * m) / answer[0]);
    
    return answer;
}
/*
정확성  테스트
테스트 1 〉	통과 (0.01ms, 3.97MB)
테스트 2 〉	통과 (0.01ms, 3.93MB)
테스트 3 〉	통과 (0.01ms, 3.82MB)
테스트 4 〉	통과 (0.01ms, 3.98MB)
테스트 5 〉	통과 (0.01ms, 3.95MB)
테스트 6 〉	통과 (0.01ms, 3.96MB)
테스트 7 〉	통과 (0.01ms, 3.93MB)
테스트 8 〉	통과 (0.01ms, 3.98MB)
테스트 9 〉	통과 (0.01ms, 3.84MB)
테스트 10 〉통과 (0.01ms, 3.97MB)
테스트 11 〉통과 (0.01ms, 3.95MB)
테스트 12 〉통과 (0.01ms, 3.96MB)
테스트 13 〉통과 (0.01ms, 3.98MB)
테스트 14 〉통과 (0.01ms, 3.94MB)
테스트 15 〉통과 (0.01ms, 3.96MB)
테스트 16 〉통과 (0.01ms, 3.94MB)*/